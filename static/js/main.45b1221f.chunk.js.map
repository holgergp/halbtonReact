{"version":3,"sources":["notesOnAString.ts","frets.tsx","strings.tsx","fretboard.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["tuning","fret","note","noteClass","rootNote","className","fretsMarkup","string","frets","map","key","fretnumber","notec","name","targetName","noted","notee","notef","noteg","notea","noteb","halftone","standardTuning","1","2","3","4","5","6","stringNumbers","Object","keys","s","parseInt","markRootNoteOnAString","stringNumber","rootNoteName","defaultFretboard","markOffsetNoteOnAString","offset","offsetNote","findOffsetNote","targetNoteIndex","findIndex","t","length","startNote","fretNumberArray","Array","noteIndexNormalized","ton","i","notesOnAString","reduce","fretboard","useState","markRootNoteOnTheFretBoard","setFretboard","fretBoardMarkup","values","onClick","markOffsetNoteOnTheFretBoard","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"0KAyJ8BA,E,qDClJf,cAAmC,IAAhCC,EAA+B,EAA/BA,KACRC,EAAmBD,EAAnBC,KACJC,EAAY,OAMhB,OAP2BF,EAAbG,SAGZD,GAAa,QACHD,IACVC,GAAa,iBAGb,0BAAME,UAAW,QACf,yBAAKA,UAAWF,MCVP,cAAqC,IAC5CG,EAD2C,EAAjCC,OACWC,MAAMC,KAAI,SAACR,GACpC,OAAO,kBAAC,EAAD,CAAMS,IAAKT,EAAKU,WAAYV,KAAMA,OAE3C,OAAO,yBAAKI,UAAU,UAAUC,I,cFP5BM,EAAQ,CAAEC,KAAM,IAAKC,WAAY,KAEjCC,EAAQ,CAAEF,KAAM,IAAKC,WAAY,KAEjCE,EAAQ,CAAEH,KAAM,IAAKC,WAAY,KACjCG,EAAQ,CAAEJ,KAAM,IAAKC,WAAY,KAEjCI,EAAQ,CAAEL,KAAM,IAAKC,WAAY,KAEjCK,EAAQ,CAAEN,KAAM,IAAKC,WAAY,KAEjCM,EAAQ,CAAEP,KAAM,IAAKC,WAAY,OAIjCO,EAAW,CACfT,EAfiB,CAAEC,KAAM,KAAMC,WAAY,cAiB3CC,EAfiB,CAAEF,KAAM,KAAMC,WAAY,cAiB3CE,EACAC,EAfiB,CAAEJ,KAAM,KAAMC,WAAY,cAiB3CI,EAfiB,CAAEL,KAAM,KAAMC,WAAY,cAiB3CK,EAfiB,CAAEN,KAAM,KAAMC,WAAY,cAiB3CM,GAGWE,EAAyB,CACpCC,EAAGP,EACHQ,EAAGL,EACHM,EAAGV,EACHW,EAAGR,EACHS,EAAGP,EACHQ,EAAGZ,GAqBCa,EAAgB,SAAC7B,GAAD,OACpB8B,OAAOC,KAAK/B,GAAQS,KAAI,SAACuB,GAAD,OAAOC,SAASD,OAEpCE,EAAwB,SAC5BC,EACAC,GAEA,OAAOC,EAAiBF,GAAc3B,MAAMC,KAC1C,SAACR,EAAYU,GAAb,sBACKV,EADL,CAEEG,SAAUH,EAAKa,aAAesB,EAC9BzB,mBAKA2B,EAA0B,SAC9BH,EACAC,EACAG,GAEA,IAAMC,EAAaC,EAAeL,EAAcG,GAChD,OAAOF,EAAiBF,GAAc3B,MAAMC,KAC1C,SAACR,EAAYU,GAAb,sBACKV,EADL,CAEEC,KAAMD,EAAKa,aAAe0B,EAAW3B,KACrCT,SAAUH,EAAKa,aAAesB,EAC9BzB,mBAqCO8B,EAAiB,SAACL,EAAsBG,GACnD,IAGMG,GAHgBrB,EAASsB,WAC7B,SAACC,GAAD,OAAaA,EAAE9B,aAAesB,KAESG,GAAUlB,EAASwB,OAC5D,OAAOxB,EAASqB,IAeZlC,EAAQ,SAAC2B,EAAsBnC,GAAvB,OAZS,SAACmC,EAAsBnC,GAC5C,IAAM8C,EAAY9C,EAAOmC,GACnBY,EAAe,YAAOC,MArIN,IAqI6BjB,QAC7CkB,EAAsB5B,EAASsB,WACnC,SAACO,GAAD,OAAeA,IAAQJ,KAGzB,OAAOC,EAAgBtC,KAAI,SAAC0C,GAC1B,OAAO9B,GAAU4B,EAAsBE,GAAK9B,EAASwB,UACpDE,GAIHK,CAAejB,EAAcnC,GAAQS,KAAI,SAACR,EAAMU,GAAP,sBACpCV,EADoC,CAEvCC,MAAM,EACNE,UAAU,EACVO,mBAgBE0B,EAZGR,EADqB7B,EAaoBsB,GAZnB+B,QAC3B,SAACC,EAAsBnB,GAKrB,OAJAmB,EAAUnB,GAAgB,CACxB3B,MAAOA,EAAM2B,EAAcnC,GAC3BmC,gBAEKmB,IAET,IG1JW,aAAoB,IAAD,EACEC,mBHqFM,SACxCnB,EACApC,GAEA,OAAO6B,EAAc7B,GAAQqD,QAAO,SAACC,EAAWnB,GAK9C,OAJAmB,EAAUnB,GAAgB,CACxB3B,MAAO0B,EAAsBC,EAAcC,GAC3CD,gBAEKmB,IACN,IG9FDE,CAA2B,IAAKlC,IAFF,mBACzBgC,EADyB,KACdG,EADc,KAI1BC,EAAkB5B,OAAO6B,OAAOL,GAAW7C,KAAI,SAACF,GACpD,OACE,yBACEG,IAAKH,EAAO4B,aACZ9B,UAAU,YACVuD,QAAS,kBACPH,EH0FkC,SAC1CrB,EACAG,EACAvC,GAEA,OAAO6B,EAAc7B,GAAQqD,QAC3B,SAACC,EAAsBnB,GAKrB,OAJAmB,EAAUnB,GAAgB,CACxB3B,MAAO8B,EAAwBH,EAAcC,EAAcG,GAC3DJ,gBAEKmB,IAET,IGvGmBO,CAA6B,IAAK,EAAGvC,MAGpD,kBAAC,EAAD,CAAQf,OAAQA,QAItB,OAAO,6BAAMmD,ICbAI,MARf,WACE,OACE,6BACE,kBAAC,EAAD,QCKcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.45b1221f.chunk.js","sourcesContent":["import { Fret, Fretboard, Note, Tuning } from './types';\n\nconst NUMBER_OF_FRETS = 20;\n\nconst notec = { name: 'C', targetName: 'C' };\nconst notecsharp = { name: 'C#', targetName: 'C#/D\\u266D' };\nconst noted = { name: 'D', targetName: 'D' };\nconst notedsharp = { name: 'D#', targetName: 'D#/E\\u266D' };\nconst notee = { name: 'E', targetName: 'E' };\nconst notef = { name: 'F', targetName: 'F' };\nconst notefsharp = { name: 'F#', targetName: 'F#/G\\u266D' };\nconst noteg = { name: 'G', targetName: 'G' };\nconst notegsharp = { name: 'G#', targetName: 'G#/A\\u266D' };\nconst notea = { name: 'A', targetName: 'A' };\nconst noteasharp = { name: 'A#', targetName: 'A#/H\\u266D' };\nconst noteb = { name: 'B', targetName: 'B/H' };\n\n// const noNote = { targetName: 'noNote' };\n\nconst halftone = [\n  notec,\n  notecsharp,\n  noted,\n  notedsharp,\n  notee,\n  notef,\n  notefsharp,\n  noteg,\n  notegsharp,\n  notea,\n  noteasharp,\n  noteb,\n];\n\nexport const standardTuning: Tuning = {\n  1: notee,\n  2: notea,\n  3: noted,\n  4: noteg,\n  5: noteb,\n  6: notee,\n};\n\nexport const dropd: Tuning = {\n  1: notee,\n  2: notea,\n  3: noted,\n  4: noteg,\n  5: noteb,\n  6: noted,\n};\n\nexport const dropc: Tuning = {\n  1: noted,\n  2: notea,\n  3: notef,\n  4: notec,\n  5: noteg,\n  6: notec,\n};\n\nconst stringNumbers = (tuning: Tuning): number[] =>\n  Object.keys(tuning).map((s) => parseInt(s));\n\nconst markRootNoteOnAString = (\n  stringNumber: number,\n  rootNoteName: string\n): Fret[] => {\n  return defaultFretboard[stringNumber].frets.map(\n    (fret: Fret, fretnumber: number) => ({\n      ...fret,\n      rootNote: fret.targetName === rootNoteName,\n      fretnumber,\n    })\n  );\n};\n\nconst markOffsetNoteOnAString = (\n  stringNumber: number,\n  rootNoteName: string,\n  offset: number\n): Fret[] => {\n  const offsetNote = findOffsetNote(rootNoteName, offset);\n  return defaultFretboard[stringNumber].frets.map(\n    (fret: Fret, fretnumber: number) => ({\n      ...fret,\n      note: fret.targetName === offsetNote.name,\n      rootNote: fret.targetName === rootNoteName,\n      fretnumber,\n    })\n  );\n};\n\n//TODO tuning param might not be needed\nexport const markRootNoteOnTheFretBoard = (\n  rootNoteName: string,\n  tuning: Tuning\n): Fretboard => {\n  return stringNumbers(tuning).reduce((fretboard, stringNumber) => {\n    fretboard[stringNumber] = {\n      frets: markRootNoteOnAString(stringNumber, rootNoteName),\n      stringNumber,\n    };\n    return fretboard;\n  }, {} as Fretboard);\n};\n\n//TODO tuning param might not be needed\nexport const markOffsetNoteOnTheFretBoard = (\n  rootNoteName: string,\n  offset: number,\n  tuning: Tuning\n): Fretboard => {\n  return stringNumbers(tuning).reduce<Fretboard>(\n    (fretboard: Fretboard, stringNumber: number) => {\n      fretboard[stringNumber] = {\n        frets: markOffsetNoteOnAString(stringNumber, rootNoteName, offset),\n        stringNumber,\n      };\n      return fretboard;\n    },\n    {} as Fretboard\n  );\n};\n\nexport const findOffsetNote = (rootNoteName: string, offset: number): Note => {\n  const rootNoteIndex = halftone.findIndex(\n    (t: Note) => t.targetName === rootNoteName\n  );\n  const targetNoteIndex = (rootNoteIndex + offset) % halftone.length;\n  return halftone[targetNoteIndex];\n};\n\nconst notesOnAString = (stringNumber: number, tuning: Tuning): Note[] => {\n  const startNote = tuning[stringNumber];\n  const fretNumberArray = [...Array(NUMBER_OF_FRETS).keys()];\n  const noteIndexNormalized = halftone.findIndex(\n    (ton: Note) => ton === startNote\n  );\n\n  return fretNumberArray.map((i: number) => {\n    return halftone[(noteIndexNormalized + i) % halftone.length];\n  }, fretNumberArray);\n};\n\nconst frets = (stringNumber: number, tuning: Tuning): Fret[] =>\n  notesOnAString(stringNumber, tuning).map((fret, fretnumber) => ({\n    ...fret,\n    note: false,\n    rootNote: false,\n    fretnumber,\n  }));\n\nexport const fretboardWith = (tuning: Tuning): Fretboard => {\n  return stringNumbers(tuning).reduce(\n    (fretboard: Fretboard, stringNumber: number) => {\n      fretboard[stringNumber] = {\n        frets: frets(stringNumber, tuning),\n        stringNumber,\n      };\n      return fretboard;\n    },\n    {} as Fretboard\n  );\n};\n\nconst defaultFretboard: Fretboard = fretboardWith(standardTuning);\n","import React from 'react';\nimport { Fret } from './types';\n\ninterface Props {\n  fret: Fret;\n}\n\nexport default ({ fret }: Props): JSX.Element => {\n  const { note, rootNote } = fret;\n  let noteClass = 'note';\n  if (rootNote) {\n    noteClass += ' root';\n  } else if (!note) {\n    noteClass += ' notDisplayed';\n  }\n  return (\n    <span className={'fret'}>\n      <div className={noteClass}></div>\n    </span>\n  );\n};\n","import React from 'react';\nimport Fret from './frets';\nimport { GuitarString } from './types';\n\ninterface Props {\n  string: GuitarString;\n}\nexport default ({ string }: Props): JSX.Element => {\n  const fretsMarkup = string.frets.map((fret) => {\n    return <Fret key={fret.fretnumber} fret={fret} />;\n  });\n  return <div className=\"string\">{fretsMarkup}</div>;\n};\n","import React, { useState } from 'react';\nimport String from './strings';\nimport {\n  markRootNoteOnTheFretBoard,\n  markOffsetNoteOnTheFretBoard,\n  standardTuning,\n} from './notesOnAString';\n\nexport default (): JSX.Element => {\n  const [fretboard, setFretboard] = useState(\n    markRootNoteOnTheFretBoard('E', standardTuning)\n  );\n  const fretBoardMarkup = Object.values(fretboard).map((string) => {\n    return (\n      <div\n        key={string.stringNumber}\n        className=\"fretboard\"\n        onClick={() =>\n          setFretboard(markOffsetNoteOnTheFretBoard('E', 3, standardTuning))\n        }\n      >\n        <String string={string} />\n      </div>\n    );\n  });\n  return <div>{fretBoardMarkup}</div>;\n};\n","import React from 'react';\nimport './App.scss';\nimport Fretboard from './fretboard';\n\nfunction App() {\n  return (\n    <div>\n      <Fretboard />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}