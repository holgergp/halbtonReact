{"version":3,"sources":["notesOnAString.ts","display.tsx","tuner.tsx","noteBubbles.tsx","noteName.tsx","fret.tsx","guitarString.tsx","fretboard.tsx","guitar.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["notec","name","targetName","noted","notee","notef","noteg","notea","noteb","halftones","standardTuning","1","2","3","4","5","6","standardTuningInfo","tuning","tunings","stringNumbers","Object","keys","map","s","parseInt","markNotesOnAString","stringNumber","rootNoteName","offset","offsetNote","findOffsetNote","fretboardWith","frets","fret","fretnumber","rootNote","markNotesOnTheFretboard","tuningName","find","t","getTuningForName","reduce","fretboard","targetNoteIndex","findIndex","length","startNote","fretNumberArray","Array","noteIndexNormalized","ton","i","notesOnAString","className","changeFretboard","useState","rootnoteName","setRootnoteName","setOffset","setTuningName","setOffsetNote","value","onChange","evt","newRootNoteName","target","key","type","newOffset","newTuningName","noteClass","noteName","toggleNotes","setToggleNotes","useHotkeys","console","log","toggleNoteClass","fretsMarkup","string","fretBoardMarkup","values","setFretboard","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.551e835c.chunk.js","sourcesContent":["import { Fret, Fretboard, Note, Tuning, TuningInfo } from './types';\n\nconst NUMBER_OF_FRETS = 20;\n\nexport const notec = { name: 'C', targetName: 'C' };\nexport const noted = { name: 'D', targetName: 'D' };\nexport const notecsharp = { name: 'C#', targetName: 'C#/D\\u266D' };\nexport const notedsharp = { name: 'D#', targetName: 'D#/E\\u266D' };\nexport const notee = { name: 'E', targetName: 'E' };\nexport const notef = { name: 'F', targetName: 'F' };\nexport const notefsharp = { name: 'F#', targetName: 'F#/G\\u266D' };\nexport const noteg = { name: 'G', targetName: 'G' };\nexport const notegsharp = { name: 'G#', targetName: 'G#/A\\u266D' };\nexport const notea = { name: 'A', targetName: 'A' };\nexport const noteasharp = { name: 'A#', targetName: 'A#/H\\u266D' };\nexport const noteb = { name: 'B', targetName: 'B/H' };\n\nexport const halftones = [\n  notec,\n  notecsharp,\n  noted,\n  notedsharp,\n  notee,\n  notef,\n  notefsharp,\n  noteg,\n  notegsharp,\n  notea,\n  noteasharp,\n  noteb,\n];\n\nexport const standardTuning: Tuning = {\n  1: notee,\n  2: notea,\n  3: noted,\n  4: noteg,\n  5: noteb,\n  6: notee,\n};\n\nexport const dropd: Tuning = {\n  1: notee,\n  2: notea,\n  3: noted,\n  4: noteg,\n  5: noteb,\n  6: noted,\n};\n\nexport const dropc: Tuning = {\n  1: noted,\n  2: notea,\n  3: notef,\n  4: notec,\n  5: noteg,\n  6: notec,\n};\n\nexport const standardTuningInfo = { name: 'Standard', tuning: standardTuning };\nexport const tunings: TuningInfo[] = [\n  standardTuningInfo,\n  { name: 'DropD', tuning: dropd },\n  { name: 'DropC', tuning: dropc },\n];\n\nconst getTuningForName = (tuningName: string): Tuning => {\n  const tuning = tunings.find((t) => t.name === tuningName);\n  return tuning ? tuning.tuning : standardTuning;\n};\n\nconst stringNumbers = (tuning: Tuning): number[] =>\n  Object.keys(tuning).map((s) => parseInt(s));\n\nconst markNotesOnAString = (\n  stringNumber: number,\n  rootNoteName: string,\n  offset: number,\n  tuning: Tuning\n): Fret[] => {\n  const offsetNote = findOffsetNote(rootNoteName, offset);\n  return fretboardWith(tuning)[stringNumber].frets.map(\n    (fret: Fret, fretnumber: number) => ({\n      ...fret,\n      offsetNote: fret.targetName === offsetNote.targetName,\n      rootNote: fret.targetName === rootNoteName,\n      fretnumber,\n    })\n  );\n};\n\nexport const markNotesOnTheFretboard = (\n  rootNoteName: string,\n  offset: number,\n  tuningName: string\n): Fretboard => {\n  const tuning = getTuningForName(tuningName);\n  return stringNumbers(tuning).reduce<Fretboard>(\n    (fretboard: Fretboard, stringNumber: number) => {\n      fretboard[stringNumber] = {\n        frets: markNotesOnAString(stringNumber, rootNoteName, offset, tuning),\n        stringNumber,\n      };\n      return fretboard;\n    },\n    {} as Fretboard\n  );\n};\n\nexport const findOffsetNote = (rootNoteName: string, offset: number): Note => {\n  const rootNoteIndex = halftones.findIndex(\n    (t: Note) => t.targetName === rootNoteName\n  );\n  const targetNoteIndex = (rootNoteIndex + offset) % halftones.length;\n  return halftones[targetNoteIndex];\n};\n\nconst notesOnAString = (stringNumber: number, tuning: Tuning): Note[] => {\n  const startNote = tuning[stringNumber];\n  const fretNumberArray = [...Array(NUMBER_OF_FRETS).keys()];\n  const noteIndexNormalized = halftones.findIndex(\n    (ton: Note) => ton === startNote\n  );\n\n  return fretNumberArray.map((i: number) => {\n    return halftones[(noteIndexNormalized + i) % halftones.length];\n  }, fretNumberArray);\n};\n\nconst frets = (stringNumber: number, tuning: Tuning): Fret[] =>\n  notesOnAString(stringNumber, tuning).map((fret, fretnumber) => ({\n    ...fret,\n    offsetNote: false,\n    rootNote: false,\n    fretnumber,\n  }));\n\nexport const fretboardWith = (tuning: Tuning): Fretboard => {\n  return stringNumbers(tuning).reduce(\n    (fretboard: Fretboard, stringNumber: number) => {\n      fretboard[stringNumber] = {\n        frets: frets(stringNumber, tuning),\n        stringNumber,\n      };\n      return fretboard;\n    },\n    {} as Fretboard\n  );\n};\n","import React from 'react';\nimport { Note } from './types';\n\ninterface Props {\n  offsetNote: Note;\n}\nexport default ({ offsetNote }: Props): JSX.Element => {\n  return <div className=\"display\">{offsetNote.name}</div>;\n};\n","import React, { useState } from 'react';\nimport { Fretboard } from './types';\nimport Display from './display';\n\nimport {\n  findOffsetNote,\n  halftones,\n  markNotesOnTheFretboard,\n  notec,\n  standardTuningInfo,\n  tunings,\n} from './notesOnAString';\n\ninterface Props {\n  changeFretboard: (fretboard: Fretboard) => void;\n}\n\nexport default ({ changeFretboard }: Props): JSX.Element => {\n  const [rootnoteName, setRootnoteName] = useState(notec.targetName);\n  const [offset, setOffset] = useState(0);\n  const [tuningName, setTuningName] = useState(standardTuningInfo.name);\n\n  const [offsetNote, setOffsetNote] = useState(notec);\n\n  return (\n    <form className=\"tuner\">\n      <span>Wenn ich vom Grundton</span>\n      <select\n        className=\"tuner--rootNote\"\n        value={rootnoteName}\n        onChange={(evt) => {\n          const newRootNoteName = evt.target.value;\n          setRootnoteName(newRootNoteName);\n          changeFretboard(\n            markNotesOnTheFretboard(\n              newRootNoteName,\n              offset,\n              standardTuningInfo.name\n            )\n          );\n          setOffsetNote(findOffsetNote(newRootNoteName, offset));\n        }}\n      >\n        {halftones.map((t) => {\n          return (\n            <option key={t.name} value={t.targetName}>\n              {t.name}\n            </option>\n          );\n        })}\n      </select>\n\n      <input\n        className=\"tuner--offset\"\n        type=\"number\"\n        value={offset}\n        onChange={(evt) => {\n          const newOffset = parseInt(evt.target.value ? evt.target.value : '0');\n          setOffset(newOffset);\n          changeFretboard(\n            markNotesOnTheFretboard(\n              rootnoteName,\n              newOffset,\n              standardTuningInfo.name\n            )\n          );\n          setOffsetNote(findOffsetNote(rootnoteName, newOffset));\n        }}\n      />\n      <span>Schritte weitergehe und</span>\n      <select\n        className=\"tuner--tuning\"\n        value={tuningName}\n        onChange={(evt) => {\n          const newTuningName = evt.target.value;\n          setTuningName(newTuningName);\n          changeFretboard(\n            markNotesOnTheFretboard(rootnoteName, offset, newTuningName)\n          );\n        }}\n      >\n        {tunings.map((t) => {\n          return (\n            <option key={t.name} value={t.name}>\n              {t.name}\n            </option>\n          );\n        })}\n      </select>\n      <span>Tuning verwende, lande ich beim</span>\n      <Display offsetNote={offsetNote} />\n    </form>\n  );\n};\n","import React from 'react';\n\ninterface Props {\n  offsetNote?: boolean;\n  rootNote?: boolean;\n}\n\nexport default ({ offsetNote = false, rootNote = false }: Props) => {\n  let noteClass = '';\n  if (rootNote) {\n    noteClass = 'note__root';\n  } else if (offsetNote) {\n    noteClass = 'note__offset';\n  } else {\n    noteClass = 'note__notVisible';\n  }\n  return (\n    <div className=\"note\">\n      <div className={noteClass}></div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { useHotkeys } from 'react-hotkeys-hook';\n\ninterface Props {\n  noteName: string;\n}\n\nexport default ({ noteName }: Props) => {\n  const [toggleNotes, setToggleNotes] = useState(false);\n  useHotkeys('ctrl+k', () =>\n    setToggleNotes((toggleNotes) => {\n      console.log('Pressed');\n      return !toggleNotes;\n    })\n  );\n  const toggleNoteClass = toggleNotes\n    ? 'notename--notesVisible'\n    : 'notename--notesInvisible';\n\n  return <div className={'notename ' + toggleNoteClass}>{noteName}</div>;\n};\n","import React from 'react';\nimport { Fret } from './types';\nimport NoteBubble from './noteBubbles';\nimport NoteName from './noteName';\n\ninterface Props {\n  fret: Fret;\n}\n\nexport default ({ fret }: Props): JSX.Element => {\n  const { offsetNote, rootNote, name } = fret;\n  return (\n    <span className={'fret'}>\n      <NoteBubble rootNote={rootNote} offsetNote={offsetNote} />\n      <NoteName noteName={name} />\n    </span>\n  );\n};\n","import React from 'react';\nimport Fret from './fret';\nimport { GuitarString } from './types';\n\ninterface Props {\n  string: GuitarString;\n}\nexport default ({ string }: Props): JSX.Element => {\n  const fretsMarkup = string.frets.map((fret) => {\n    return <Fret key={fret.fretnumber} fret={fret} />;\n  });\n  return <div className=\"string\">{fretsMarkup}</div>;\n};\n","import React from 'react';\nimport GuitarString from './guitarString';\nimport { Fretboard } from './types';\n\ninterface Props {\n  fretboard: Fretboard;\n}\n\nexport default ({ fretboard }: Props): JSX.Element => {\n  const fretBoardMarkup = Object.values(fretboard).map((string) => {\n    return (\n      <div key={string.stringNumber} className=\"fretboard\">\n        <GuitarString string={string} />\n      </div>\n    );\n  });\n  return <div>{fretBoardMarkup}</div>;\n};\n","import React, { useState } from 'react';\nimport {\n  notec,\n  markNotesOnTheFretboard,\n  standardTuningInfo,\n} from './notesOnAString';\nimport Tuner from './tuner';\nimport Fretboard from './fretboard';\n\nexport default (): JSX.Element => {\n  const [fretboard, setFretboard] = useState(\n    markNotesOnTheFretboard(notec.targetName, 0, standardTuningInfo.name)\n  );\n\n  return (\n    <div>\n      <Tuner changeFretboard={setFretboard} />\n      <Fretboard fretboard={fretboard} />\n\n      <footer>Press CTRL+k to toggle notenames</footer>\n    </div>\n  );\n};\n","import React from 'react';\nimport './App.scss';\nimport Guitar from './guitar';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Guitar />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}